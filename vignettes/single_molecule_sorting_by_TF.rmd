---
title: "single_molecule_sorting_by_TF"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    highlight: tango
vignette: >
  %\VignetteIndexEntry{SingleMoleculeFootprinting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  # comment = "#>", 
  tidy = FALSE, 
  cache = FALSE, 
  results = 'markup'
)
```

## Introduction
This vignette exemplifies how to perform single molecule sorting based on prior TF binding site annotation as per [SÃ¶nmezer et al., 2021](https://doi.org/10.1016/j.molcel.2020.11.015) and [Kleinendorst & Barzaghi et al., 2021](https://doi.org/10.1038/s41596-021-00630-1).  

## Single TF
```{r, eval=TRUE}
OneTFState()
```

## TF pair
```{r, eval=TRUE}

```













Ultimately though, we want to classify reads based on their patterns of molecular occupancy. To that end we provide the functions `SortReadsBySingleTF` and `SortReadsByTFCluster` to classify reads based either on the occupancy patterns of one or multiple transcription factors. \

Under the hood, the classification is based on the definition of $n+2$ bins (with $n$ being the number of TFs). The $n$ bins are each centered around one of the TFBSs of interest, while the 2 extra bins are located upstream and downstream of the two outmost TFBSs. \

For `SortReadsBySingleTF`, the coordinates of the bins relative to the center of the TFBS are [-35;-25], [-15;+15], [+25,+35]. Instead, the function `SortReadsByTFCluster` draws a bin with coordinates [-7;+7] around the center of each TFBS, a bin with coordinates [-35;-25] relative to center of the most upstream TFBS and a bin with coordinates [+25,+35] relative to the center of the most downstream TFBS. The user can also employ custom coordinates by specifying them explicitly using the function `SortReads`. \

For each read, the binary methylation status of the cytosines contained in each bin is averaged to either a 0 or a 1 such that each read is eventually represented as sequence of $n+2$ binary digits, for a total of $2^{(n+2)}$ possible sequences. \

Here, we show a usage case for the `SortReadsByTFCluster` function, as we have already identified the double binding of NRF1 at the genomic site under scrutiny. Usage and exploration of the output is identical for the other function, except for the the format of the *TFBSs* argument which should consist of a GRanges object of length 1 for `SortReadsBySingleTF` and of length $>$ 1 for `SortReadsByTFCluster`.
```{r, eval=TRUE}
SortedReads = SortReadsByTFCluster(MethSM = Methylation[[2]], TFBSs = TFBSs)
```

```{r, echo=FALSE}
print(paste0("Number of retrieved states: ", as.character(length(SortedReads))))
print("States population:")
unlist(lapply(SortedReads, length))
```
N.b. non-populated states are not returned. \

The output of each of these sorting functions can be passed directly as the `SortedReads` argument of the `PlotSM` function.
```{r}
PlotSM(MethSM = Methylation[[2]], range = Region_of_interest, SortedReads = SortedReads)
```

N.b. despite sorting reads by a TF cluster is in principle possible with clusters of any size, as of now the `PlotSM` function can only deal with TF pairs.


In order to be quantitative about these observations, the user can employ the `StateQuantificationPlot`. The function outputs a bar plot annotated with the percentage of reads found in each state. The function takes, as argument, the output of either of the two sorting functions.
```{r}
StateQuantificationPlot(SortedReads = SortedReads)
```

Finally, we provide the wrapper function `PlotSingleSiteSMF` to plot at once the three kinds of information detailed above and to export results as a pdf.
```{r, eval=FALSE}
PlotSingleSiteSMF(ContextMethylation = Methylation, 
                  sample = MySample, 
                  range = Region_of_interest, 
                  SortedReads = SortedReads, 
                  TFBSs = TFBSs, 
                  saveAs = NULL)
```

## sessionInfo
```{r sessionInfo, echo=FALSE}
sessionInfo()
```